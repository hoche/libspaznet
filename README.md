# libspaznet

A high-performance, cross-platform network server library written in C++20 using coroutines.

## Features

- **Cross-platform I/O multiplexing:**
  - kqueue on BSD/macOS
  - epoll on Linux
  - poll on other Unix systems
  - IOCP on Windows

- **Coroutine-based async I/O:** Uses C++20 coroutines as the primary execution model
- **Thread-safe:** Can run either Single-threaded or multi-threaded with lock-free task queues (minimal mutex usage)
- **Protocol support:**
  - UDP
  - HTTP/1.1
  - HTTP/2
  - QUIC & HTTP/3 (partial)
  - WebSockets

## Quick Start

### Building

```bash
# Using Make (recommended)
make

# Or using CMake directly
mkdir build && cd build
cmake ..
make
```

### Running Tests

```bash
# Run all tests
make test

# Run specific test suites
make test-unit
make test-integration
make test-performance
```

### Code Quality

```bash
# Format code
make format

# Check formatting
make check-format

# Run static analysis
make check-tidy      # clang-tidy
make check-cppcheck  # cppcheck

# Run all checks
make lint
```

## Threading Modes

The `Server` constructor accepts a thread count parameter:

- **`Server(0)`** - Single-threaded mode: All work runs on the main event loop thread
- **`Server(N)`** - Multi-threaded mode: N worker threads process coroutines in parallel

The library uses lock-free task queues for efficient work distribution. Coroutines can migrate between threads as they await I/O operations, but the scheduler ensures thread-safe execution.

For performance characteristics across different thread counts, see `thread_mode_report.md` (generated by `./bench_thread_modes`).

## Testing

The project includes extensive unit, integration, and performance tests using Google Test.

### Running Tests

```bash
cd build
ctest
```

Or run tests individually:

```bash
./test_unit          # Run unit tests
./test_integration    # Run integration tests
./test_performance    # Run performance benchmarks
```

### Test Coverage

**Unit Tests:**
- Task and TaskQueue (coroutine scheduling, thread safety)
- PlatformIO implementations (epoll/kqueue/poll/IOCP)
- IOContext (event loop, task scheduling)
- HTTP handler (request/response serialization)
- WebSocket handler (frame parsing and serialization)
- HTTP/2 handler (frame structure)
- QUIC handler
- HTTP/3 handler (partial)

**Integration Tests:**
- TCP server (connection handling, multiple ports)
- HTTP server (request/response cycle, multiple requests)
- WebSocket server (frame handling, ping/pong)
- UDP server (packet handling, different sizes)
- Concurrent connections (load testing, burst connections)

**Performance Tests:**
- Throughput benchmarks (requests per second)
- Latency measurements (min, max, mean, median, P95, P99)
- Concurrent connection performance
- iperf/iperf3 integration for bandwidth testing

### Performance Benchmarking

For detailed bandwidth testing using iperf3:

```bash
# Make script executable
chmod +x tests/performance/run_iperf_benchmark.sh

# Run benchmark
./tests/performance/run_iperf_benchmark.sh
```

To generate a comprehensive performance report comparing thread modes:

```bash
cd build
./bench_thread_modes > thread_mode_report.md
```

This generates a report showing HTTP throughput and latency across different thread counts, as well as raw TCP/UDP bandwidth measurements. See `tests/performance/README.md` for detailed performance testing documentation.

## Code Quality Tools

The project includes support for various code quality tools:

### clang-format

Format code according to the project style:

```bash
make format        # Format all files
make check-format  # Check formatting without modifying files
```

### clang-tidy

Run static analysis:

```bash
make check-tidy
```

### cppcheck

Run additional static analysis:

```bash
make check-cppcheck
```

### Combined Checks

Run all code quality checks:

```bash
make lint
```

## Example Usage

```cpp
#include <libspaznet/server.hpp>
#include <libspaznet/handlers/http_handler.hpp>

class MyHTTPHandler : public spaznet::HTTPHandler {
public:
    spaznet::Task handle_request(
        const spaznet::HTTPRequest& request,
        spaznet::HTTPResponse& response,
        spaznet::Socket& socket
    ) override {
        response.status_code = 200;
        response.set_header("Content-Type", "text/plain");
        response.body = {'H', 'e', 'l', 'l', 'o'};
        co_return;
    }
};

int main() {
    spaznet::Server server(4);  // 4 worker threads (0 = single-threaded)
    server.set_http_handler(std::make_unique<MyHTTPHandler>());
    server.listen_tcp(8080);
    
    // Optional: Monitor server statistics
    auto stats = server.get_statistics();
    std::cout << "Active coroutines: " << stats.active_coroutines << std::endl;
    
    server.run();
    return 0;
}
```

## Architecture

- **IOContext:** Manages the event loop and coroutine scheduling
- **PlatformIO:** Platform-specific I/O multiplexing abstraction
- **Server:** High-level server interface
- **Handlers:** Protocol-specific request handlers (UDP, HTTP, HTTP/2, WebSocket, QUIC, HTTP/3)

The library uses C++20 coroutines for async operations, optionally with threads only used to run multiple coroutines in parallel. Task scheduling is lock-free using atomic operations.

### Monitoring and Statistics

The `Server` class provides a `get_statistics()` method that returns lock-free statistics:

```cpp
auto stats = server.get_statistics();
// stats.active_requests - Currently active HTTP requests
// stats.total_coroutines_created - Total coroutines created
// stats.active_coroutines - Currently active coroutines
// stats.total_memory_bytes - Estimated memory in use (bytes)
```

Statistics are updated atomically and can be read from any thread without blocking.

For detailed information about the coroutine execution model, thread scheduling, and I/O handling, see `docs/concurrency-and-coroutines.md`.

## Requirements

- C++20 compiler (GCC 10+, Clang 10+, MSVC 2019+)
- CMake 3.20+
- Make (optional, for convenience targets)

### Optional Tools

- clang-format (for code formatting)
- clang-tidy (for static analysis)
- cppcheck (for additional static analysis)
- iperf2 or iperf3 (for performance benchmarking)

## Development Workflow

```bash
# Set up development environment
make dev-setup

# Make changes, then:
make format      # Format code
make lint        # Run all checks
make test        # Run tests
make build       # Build
```

